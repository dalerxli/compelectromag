//Time integration of a wave equation with the newmark scheme:
//Reference: Time Domain Electromagnetics - (reference from Hafner;s book - available at Science Direct)
//Gregoire Allaire - Numerical Analysis and Optimization - pg 

//To simulate with obstacle:
//FreeFem++ freefemNewmarkEMwave.edp -freq 20 -of radar_f20_obst.data -obst 1

//To simulate for different freqs with bash
//for i in 20 25 30 35;
//  do  
//    FreeFem++ freefemNewmarkEMwave.edp -freq $i -of radar_f$i_obst.data -obst 1;
//    FreeFem++ freefemNewmarkEMwave.edp -freq 20 -of radar_f20_noObst.data -obst 0; 
//  done
//

//saved at the Dropbox folder for reference.
//////////////////////////////////////////////////////////////////////////
//how to - timelag of signals:
//http://bagustris.blogspot.ch/2011/11/calculate-time-lag-from-cross.html


//Octave command to extract the distance of the source from the obstacle
//In position 5 is the source signal and in position 2 the signal measured inside the obstacle.
//dist=[];for ii = [20 25 30 35 50 60 70 80];a=load(['radar_f',int2str(ii),'_obst.data']);ind = find(max((xcorr(a(:,5),a(:,2))))==xcorr(a(:,5),a(:,2)));dt=a(2,1)*ind;dist = [dist; dt*3];end

//macro incidentWave(t,T,cc,theta) exp(-(4./T * (-1.* cc * (t) + x * cos(theta)+y*sin(theta)))^2) //EOM
include "getARGV.idp"

real tgv = 0;
real[int] sourcepoint(2);
sourcepoint=[0.2,0.2];

macro borderline(a, b, lab) (t=0,1) { x = a[0]+t*(b[0]-a[0]); y = a[1]+t*(b[1]-a[1]); label = lab; } // EOM
//macro incidentWave(t,T,cc,theta) (1-x<t*cc?1.:0.)*0*sin(-2.*pi/(T*cc)*x - 2*pi/T*t) //EOM
macro initConds() (exp(-500*((sourcepoint[0]-x)^2+(sourcepoint[1]-y)^2))) //EOM
//Sine wave excitation(To keep track of frequncy for easier formulation of ABCs):
macro incidentWave(t,T,cc,theta) (t<T)*(-0.01+sourcepoint[0]<=x)*(x<=0.01+sourcepoint[0])*(-0.01+sourcepoint[1]<=y)*(y<=sourcepoint[1]+0.01)*(sin(500*pi/T*t)*0) //EOM
macro penaltyRegion() (-0.05+sourcepoint[0]<=x)*(x<=0.05+sourcepoint[0])*(-0.05+sourcepoint[1]<=y)*(y<=sourcepoint[1]+0.05) //EOM
macro knownEfield(tt) penaltyRegion*sin(2*pi/T*tt) //EOM

macro vwave() 0*sin(2*pi*x)*cos(2*pi*y) //EOM
macro uwave() 0*sin(3*pi*x)*cos(4*pi*y) //EOM
macro Mvarf(multWith,uTrial,uTest) int2d(Th)(multWith*uTrial*uTest) //EOM
macro Kvarf(multWith,uTrial,uTest) (int2d(Th)(multWith*dx(uTrial)*dx(uTest) +multWith*dy(uTrial)*dy(uTest))  )//EOM
macro KvarfBC(t,m,uTest) = int2d(Th)(m*uTest*t) //EOM


real[int] sensorpoints(4);
sensorpoints=[0,1.5,
			  0,0];


real t=0.;
real f ;
f= getARGV("-freq",1);/*kHz = 1/[ms]- the operating frequency of a metal detector (Google - random)*/
real T=1/f;
real omega = 2*pi*f;

//Newmark's parameters;
real alpha = 0.25;
real delta = 0.5;
complex cExt = 3, /* [km]*[ms]^-1 */
		cCyl=1e-6,/*relative permitivity of steel*/
		cABC=0; //speed of light
		//The cABC can't be straightforwardly defined here(time domain simulation)!! It is not a simple function of the sigma factor...

if(getARGV("-obst","int")==0){
	cCyl=cExt;
}

real dt = T/60;
real lamda = real(cExt) * T ;
real tFinal = dt*100;
//border Ch(t=0,2*pi) {x=0.5+0.3*cos(t);y=0.5+0.3*sin(t);}
border S1 (t=0,1) { x = t  ; y=0  ; label =  1; } 
border S2 (t=0,1) { x = 1  ; y=t  ; label =  2; } 
border S3 (t=0,1) { x = 1-t; y=1  ; label =  3; } 
border S4 (t=0,1) { x = 0 ; y=1-t ; label =  4; }


// PML Box
real boxD = 10;
border So1 (t=0,1) { x = -boxD+(2*boxD+1)*t  ; y=-boxD    ; label =  5;}
border So2 (t=0,1) { x = boxD+1  ; y=-boxD+(1+2*boxD)*t   ; label =  6;}
border So3 (t=0,1) { x = boxD+1 + (-1-2*boxD)*t; y=boxD+1 ; label =  7;}
border So4 (t=0,1) { x = -boxD ; y=(1+boxD)-t*(1+boxD*2)  ; label =  8;} 
border Bext (t=0,2*pi) {x=0.0+1.5*cos(t);y=0.5+1.5*sin(t) ; label = 99;}

border Bsp(t=0,2*pi) { x = 0.5+0.1*cos(t); y = 0.5+0.1*sin(t); label = 9; }

real[int] disc(5);
disc = [40,40,40,40,50];
//~ mesh Th =buildmesh(So1(dsp(disc[4])*/);

mesh Th =buildmesh(S1(disc[0])
					+S2(disc[1])
					+S3(disc[2])
					+S4(disc[3])
					/*+So1(disc[1])
					+So2(disc[2])
					+So3(disc[2])
					+So4(disc[3])*/
					/*Bsp(disc[4]*0.5)+Bext(disc[4]*2)*/);
//~ 
//~ mesh Th =buildmesh(S1(disc[0])
					//~ +S2(disc[1])
					//~ +S3(disc[2])
					//~ +S4(disc[3])
					//~ +bPML(40)
					//~ +Bsp(disc[4]));

//plot(Th,wait=true);

fespace Ph(Th,P0);
fespace Vh(Th,P2);

Ph reg=region;
Ph<complex> c;

real regCyl = real(reg(0.5,0.5 ) );
real regExt = real(reg(0.01,0.01));
real regABC = real(reg(-0.1,-0.0));
real pmlOn  = 0;
Ph sigmaZ = (y<=0)*(-y)+(y>=1)*(-1+y)+(x>=1.)*(-1+x)+(x<=0)*(-x);

cout<<"The abc region"<<endl;
cout<<regABC<<endl;
//plot(reg,wait=true,fill=true,value=true);

Ph<complex> totPML = 1/(1+sigmaZ*1i);
//plot(totPML,wait=true,fill=true,value=true,cmm="totPML");

Ph rePml = real(totPML);
Ph imPml = real((totPML-real(totPML))^2);

c =  (real(reg)==real(regCyl) ? cCyl				:0.+0i)+
	 (real(reg)==real(regExt) ? cExt				:0.+0i);/*+
	 (real(reg)==real(regABC) ? (cABC*totPML*pmlOn -cExt*(pmlOn-1))		:0.+0i);*/

string r ;
r="regions "+regCyl + "," + regExt+","+regABC;

Vh<complex> uTrial,uOld,uLoad;
uTrial = initConds;
real theta = 30./(2*pi);

/*
 * All these parameters make sense 
 * in the context presented in "Time Domain Electrodynamics"
 * but to really understand what the boundary conditions are 
 * I had to check out the "Numerical Analysis andOptimization" Book (Allaire)
 */

//For the Mm matrix
Ph<complex> mmL=(1./c^2);
real mkL=alpha*dt^2;

//For the Lm Matrix
Ph<complex> mmM=(2./c^2);
real mkM=dt^2*(-0.5-delta+2*alpha);

//For the Nm matrix
Ph<complex> mmN=-1./c^2;
real mkN=(dt^2*(-0.5+delta-alpha));

Vh<complex> temp1x;
uOld[] = uTrial[];

string fname;
string obsString = getARGV("-obst","int")==1?"_obst":"_noobst";
//fname = getARGV("-of","string");

fname = "radar_f" + f + obsString+".data";



ofstream field(fname);

for(real t=0;t<tFinal;t+=dt){	
//for(int i=0;i<1;i++){
	Vh ureal=real(uTrial);
	plot(Th,(ureal),dim=2,wait=false,fill=true,value=true);

	cout<<"Saving in "<<fname<<", obst= "<<getARGV("-obst","int")<<" cCyl="<<real(cCyl)<<endl;
	cout<<"t/tFinal="<<t/tFinal*100<<"   percent complete"<<endl;
	field<<t<<","                                          /*1*/
			<<ureal(0.39,0.5)<<","                        /*2*/  
			<<ureal(sensorpoints[0],sensorpoints[1])<<","  /*3           0.0, 1.5 */
			<<ureal(sensorpoints[2],sensorpoints[3])<<","  /*4 sensor at 0.0, 0.0 */
			<<ureal(sourcepoint[0],sourcepoint[1])<<","    /*5 source at 0.5, 0.5 */
			<<int1d(Th,9)(ureal)<<endl;                    /*6*/
	
	varf Lmatr(uTrial,uTest) =  Mvarf(mmL,uTest,uTrial) 
									+Kvarf(mkL,uTest,uTrial)
									-int2d(Th)(mkL*uTest*tgv*penaltyRegion);
										
	varf Mmatr(uTrial,uTest) =  Mvarf(mmM,uTest,uTrial) 
									+Kvarf(mkM,uTest,uTrial)									
									-int2d(Th)(mkM*uTest*tgv*penaltyRegion);
;
	varf Nmatr(uTrial,uTest) =  Mvarf(mmN,uTest,uTrial)
									+Kvarf(mkN,uTest,uTrial)
									-int2d(Th)(mkN*uTest*tgv*penaltyRegion);
;;

	//The load vector is only obvious in the context of Allair's book:
	//I have to multiply the current load by (0.5+delta-2*theta) (obvious because it comes from the Cvarf formulation
	//and also the previous load vector by (0.5 - delta + theta)
	//and the next load vector by theta. Then I have to collect all the terms related to the 
	//current displacement and add them to my load vector. 
	varf Bvect(uTrial,uTest) = int2d(Th)(uTest*( (0.5-delta+alpha) *dt^2  * ( incidentWave(t-dt,T,c,theta) ) //Load in Previous step
												+(0.5+delta-2*alpha)*dt^2 * ( incidentWave(t,T,c,theta) )   //Load in Current step
												+(alpha)*dt^2             * ( incidentWave(t+dt,T,c,theta) ))) //Load in Previous Step
							   +int2d(Th)(uTest*((0.5-delta+alpha) *dt^2  * knownEfield(t-dt)
												+(0.5+delta-2*alpha) *dt^2* knownEfield(t)
												+(alpha)*dt^2 	*	 		knownEfield(t+dt))*tgv);  //The penalty term (I think it should be here...)


	//~ varf PenaltyVectVarf(uTrial,uTest) = -int2d(Th)(uTest*tgv*knownEfield);
	//~ Vh<complex> PenVect;
	//~ PenVect[] = PenaltyVectVarf(0,Vh);

	matrix<complex> Lm = Lmatr(Vh,Vh);
	matrix<complex> Mm = Mmatr(Vh,Vh);
	matrix<complex> Nm = Nmatr(Vh,Vh);
	verbosity=2;

	//set(Lm,solver=sparsesolver);
	set(Lm,solver = GMRES);
	uLoad[] = Bvect(0,Vh);
	//uLoad[]=uLoad[]/*+PenVect[];*/
	
	temp1x[] = Mm*uTrial[];
	uLoad[]  = uLoad[] + temp1x[];	
	temp1x[] = Nm*uOld[];
	uLoad[]  = uLoad[]+temp1x[];
	uOld[]=uTrial[];
	uTrial[]=Lm^-1*uLoad[];
	
	verbosity=1;
	
	cout<<"t="<<t<<endl;
}
